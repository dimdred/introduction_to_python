## Встроенные типы и синтаксис языка
# -*- coding: utf-8 -*-

# Empty value
None

# Logical type
True
False

True == 1
False == 0


# ложные знаечения, для проверки есть ли данные в списке
bool([])
bool([1])

# Числа (Целыеб с плавающей запятой)

#строки
"стр\"ока",
"строка", 'строка', \
print ('hello \n world')

# сырые строки
print(r'hello\nworld')

# многострочные строки

"""
Hello
world
"""


# списки List: можем переписать в любой момент по индексу
l=[1,2,3]
[1,[2,'three'],3] # вложенный список

# Кортежи: Tuple -- неизменяемый список! используется для константных значений
c=(1,'spam',4,'U')

# доступ к элементу
l[0]


# Срезы: Считаются проежутки между элементами
l[1:2:2] #(с какого, по какой, шаг)

l=[1,2,3,4,5,6]
l[1:6:2]

l[-1] # взятие последнего элемента
l[-2]


# Генерация списка целых чисел (удобно для цикла)
range(5)
list(range(5)) # созданный список

range(3,12,3)

# создание пустого списка
empty_list = []
empty_list = list() # лучше использовать (нагляднее)

# Способы получения методов словаря
dir(list)
dir([])
dir(empty_list)


# строки это последовательность (неизменяемые списки)
'hello' [0]
'hello' [0:4]
dir('') # методы для строк

# Словари Dictonary
{'food': 'spam', 'taste': 'table'} # {ключ-любое неизменяемое значение(строка,кортеж) : само значение}
d = {"a": 1, "b":2}
d["a"] # обращаемся к элементу по ключу

# Создание пустого словаря
d = {}
d = dict
# методы словаря
dir(dict)

# Множества Set: Значения не могут повторяться! Применяется для удаления дублей!
z = set('abc')
len(z) #3
z2 = set('abbbcc')
len(z2) #3

s1 = {1, 2, 3}
s2 = {4, 5, 6}
#пересчение
s1 & s2
#Объединение
s1 | s2
# Разность
s1 - s2
s2 - s1
#Сравнение
s1 > {1, 2}
s1 > {4, 5}

# методы множества
dir(set)

# модуль collections
# дополнительные контейнеры
from collections import *
Point = namedtuple('Point',['x','y']) # новый тип Point с 2мя переменными (хорошо для координат)
p1 = Point(x=11, y=22)
p2 = Point(33, 44)
p1.x + p2.y
p1

# двоичные данные: bytes,(неизменяемый) byte-array(изменяемый)
b'abc'
b'\x01\x02'
bytes('abc','ascii') # меняем кодировку на ascii
bytes('абв','ascii') # нету русс букв
bytes('абв','utf8')
# кодируем и расскодируем строки
B = 'spam'.encode()
B.decode()
# bytearray изменяемая последовательность
B = bytearray('spam','latin1')
B[0] = 65 # код буквы A

# Файлы
myfile = open('03.py','r')
type(myfile)
# Сами типы. Базовые в python
type(type)
type(object) # все типы наследуються от типа object

# Типы структурных элементов программ
#clas, function, module
import re # регулярка
type(re)

# Оперции над типами
dir(list) #просмотр содержимого
help(list) #помощь по типу
dir(bytes)


# Структура программы на Python
# Модули ->инструкции -> выражения -> объекты

a = 1 # объекты
if a == 1:
    print('Good')
else:
    print('Bad')

a = 1; b = 2; print(a, b) # плохо, код не читабильный!

# форматирование
my_fun(arg1,
       arg2,
       arg3)

# Разрыв строки (обратный слеш)
a = \
    2

# динамическая типизация
# тип имеет не переменная а ее содержимое
a = 1
type(a)
a = 'a'
type(a)

# разделяеммые ссылки
a = 42
b = a
#a -----> 42
#b -------^
a = 'spam'
#a -----> spam
#b ------> 42

# функция id: уникальный идентификатор объекта (его адресс)
id(1)
# разделяеммые ссылки и объекты
L1 = [1, 2, 3]
L2 = L1
id(L2) == id(L1)
#L1 ----->[1, 2, 3]
#L2 -------^
L1.append(4)
#L1 ----->[1, 2, 3, 4]
#L2 -------^
id(L2) == id(L1)

# копия списка (поможет избежать изменения 2х списков см выше)
L2 = L1[:]
id(L2) == id(L1)

L2 = L1
L2 == L1 # проверяем по содержимому
L2 is L1 # id(L2) == id(L1)

L2 = [1, 2, 3, 4]
L2 == L1
L2 is L1 # разные объекты (в памяти)


# Динамическая типизация повсюду (не всегда понятен тип переменной)
action(enviroment, config)


## Инструкции
# присваивание
a = 1
b = 2
a, b = b, a
a, *b = 'good', 'bad', 'ugly' # все значения после 1го в список!

# Вызовы и другие выражения
#  . -- вызов метода (объект.метод)
log.write('spam, ham')
# Вызов функции
print('Spam', joke)
# и др.

# Встроенные инструкции
# import, def, class, if, while и др.
if a == 1:
    print(1)
elif a == 2:
    print(2)
elif a == 4:
    print(4)
else:
    print(3)

# трехместное выражение if/else
A = Y if X else Z #(A = Y если X true иначе A = Z)

# while
while a > 1: # условное выражение
    print(a) # тело цикла (выполняется каждый раз пока условное выражение true)
    break # выходит за тело цикла (253 line)
    continue # возврат в начало цикла
else: # необязательная часть
    print(0) # выполняется если выход из цикла производится не инструкцией break

# break, continue, pass, else
while a > 1:
    a = a - 1
    if a % 2:
        continue #если четное возвращаемся в начало цикла
    result = action(a)
    if result:
        break # выйти из цикла, пропустив часть else
else:
    print('bad action')

# for (может использоваться только с некоторой последовательностью)
for i in range(10): # присваивает элементы объекта с переменной цикла
    res = action(i)
    if res > 0: break # выход из цикла минуя болк else
    if res < 0: continue # переход в начало цикла
else:
    print('good') # если не был вызван break

# простой вариант:
for i in range(10):
    action(i) # action будет запускаться 10 раз от 0 до 9

## Приемы программирования циклов
# Счетные циклы: range
list(range(5))
list(range(10,20))
list(range(5,30,7))
for i in range(3):
    print(i, 'Pythons')

# Генерирование индексов и элементовЖ enumerate
S = 'spam' # список, в нашем примре строка
for (offset, item) in enumerate(S):
    print(item, 'appears at offset', offset)
# получаем индекс и элемент S[0] = s и ...

# сортировка массива
# у нас массив - строка
origin = 'avdsdf'
sorted(origin) # функция создает копию, не меняя массив
origin
l = [3, 2, 5]
l.sort() # метод сохраняет массив отсортированным
l

# Менеджер контекста (Обертка над объектом). Работа с файлами, не нужно закрывать! Работать с файлами лучше так! (не всегда подойдет!)
with open('test.txt') as myfile:
    for line in myfile:
        print(line)


# УДОБНЫЙ ПОИСК ПОДСТРОКИ (оператор in)
s = 'spam'
'm' in s # вернет True если существует
# Или элемента в массиве
1 in [0, 1, 2]
# индекс не находит. для быстрой проверки
if 1 in [0, 1, 2]:
    pass # заглушка. ничего не делает, компилятор не ругается!

# приведение к булевскому типу или проверка тру или фолсе
bool(None)


# Утинная типизация!
# если объект реализует все методы какого-то интерфейса,
# то говорят, что он реализует этот интерфейс.

## Итераторы
# Для унификации работы со списками содан специальный протокол.
# Объект реализующий этот протокол называется "Итератор"
# Если тип является итератором тио он должен поддерживать 2 метода: __iter__() и __next__()
# итераторы файлов

f = open('test.txt')
f.readline()
lines = f.readlines()

# итераторы встроенных типов
L = [1, 2]
dir(L)
LI = iter(L)
dir(LI)
LI.__next__() # перебираем элементы класса 1, 2 , ошибка(нету элементоа)

# работа с элем массива вс помощью цикла
for l in L:
    print(L)

# создание списков в виде инструкции
L = [i for i in range(5)]
L = [i**2 for i in range(5)]
# тожк самок в виде цикла
L = []
for i in range(5):
    L.append(i)

# список нечетных чисел
L = [i for i in range(5) if i % 2]
# тоже самое в виде цикла
L = []
for i in range(5):
    if i % 2:
        L.append(i)

# множество
{i for i in range(5)}

# словарь
{i: i+1 for i in range(5)} # i - ключ, i+1 - значение, вместо range - все что итерируется, списки, объекты, файлы (список строк файлов)

# с помощью цикла
d = {}
for i in range(5):
    d[i] = i + 1


# создание последовательностей в виде литералов
[0, 1, 2]
[i for i in range(3)]

{0, 1, 2}
{i for i in range(3)}

{0:1, 1:2, 2:3}
{i: i+1 for i in range(3)}

# Общий вид генераторов
# Генераторы - функции позволяющие работать асинхронно
# один из способов асинхронной работы
# отличается от функции специальным оператором yield (позволяет сохранять состояние)

def power(start):
    print('power is called the first time')
    for i in range(start, start+5):
        yield i * i
    print('power is called the lsst time')

for p in power(1):
    print(p)

# выражения-генераторы ()-генератор
(i for i in range(5))

# удобно для работы с огромными файламию(ГБ)(читать по строкам).
i = (i for i in range(5))
type(i)

i.__next__()
i.__next__()
i.__next__()

# специальный модуль для итераторов. Нужно посмотреть!
from itertools import *
cycle('ABCD') # цикличный итератор
repeat(10,3) # повторяем некоторе значение нужное число раз!

## Функциональные инструменьы
# генераторы списков и функция map
m = map(ord, 'spam') # ord - вместо символа берет числовове значение
# map для обработки списков
[ord(i) for i in 'spam'] # эквивалент map
dir(m)
list(m)
help(ord)

# функция filter? фильтруе только true значения
L = [1, 0, None, True, 2]
list(filter(bool, L))
[i for i in L if i] # эквивалент


# параллельный обход: zip
L1 = [1,2,3,4]
L2 = [4,6,7,8]
zp = zip(L1,L2) # делаем из списка 2ой список (словарь)
list(zp)
# удобно для создания словаря

# применяем 2 словаря в 1м цикле
for (x, y) in zip(L1, L2):
    print(x, y, '--', x + y)

#  Полезные функции
L = [1, 0, None, True, 2]
any(L) # если есть хотя бы 1 true то вернет true
all(L) # только когда все true